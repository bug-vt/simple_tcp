#!/usr/bin/python3 -u


import sys
import socket
import time
import datetime
import select
import json

from base64 import b64encode

MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 30
SEQUENCE = 0

class Sender:
  def __init__ (self, udp_ip, udp_port):
    # Record ip address and port number of the receiver
    self.dest = (udp_ip, udp_port)
    # Set up the UDP socket
    self.sock = socket.socket (socket.AF_INET, socket.SOCK_DGRAM) 
    self.sock.settimeout(TIMEOUT)

  def log(self, msg):
    log_msg = datetime.datetime.now().strftime("%H:%M:%S.%f") + " 4254send: " + msg + "\n"
    sys.stderr.write (log_msg)

  def sendNextSegment (self):
    global SEQUENCE

    data = sys.stdin.buffer.read(DATA_SIZE)
    if (len(data) > 0):
      msg = json.dumps({"sequence": SEQUENCE, "data": b64encode(data).decode(), "ack": False, "eof": False})
      if self.sock.sendto(msg.encode(), self.dest) < len(msg):
        self.log("[error] unable to fully send packet")
      else:
        self.log("[send data] " + str(SEQUENCE) + " (" + str(len(data)) + ")")
      SEQUENCE+=len(data)
      return True
    else:
      return False

  def recvAck (self):
    return self.sock.recvfrom (MSG_SIZE)

  def endConnection (self):
    self.sock.sendto(json.dumps({"eof": True, "data": "", "sequence": SEQUENCE, "ack": False}).encode(), self.dest)
    self.sock.close ()



def main (argv):
  # Find IP and port number from command line argument
  UDP_IP = argv[1].split (":")[0]
  UDP_PORT = int (argv[1].split (":")[1])

  sender = Sender (UDP_IP, UDP_PORT) 

  # Send first packet
  sender.sendNextSegment ()

  # Now read in data, send packets
  while True:
    sender.log("ABOUT TO SLEEP")
    try:
      result = sender.recvAck ()
    # If nothing is ready, we hit the timeout
    except socket.timeout:
      receiver.log("[error] timeout")
      sys.exit(-1)

    (data, addr) = result
    try:
      decoded = json.loads(data.decode())
      sender.log("[recv pkt] " + str(decoded))
      sender.log("[recv ack] " + str(decoded['ack']))

      # If there is an ack, send next packet
      if decoded['ack'] == SEQUENCE:
        # Try to send next packet; break if no more data
        if (not sender.sendNextSegment ()):
          break
    except (ValueError, KeyError, TypeError):
      sender.log("[recv corrupt packet]")

  sender.endConnection ()
  sys.exit(0)


if __name__ == '__main__':
  main (sys.argv)
