#!/usr/bin/python3 -u


import sys
import socket
import time
import datetime
import select
import json

from base64 import b64encode
from window import Window 

MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 1
SEQUENCE = 0
MAX_WINDOW_SIZE = 100

class Sender:
  '''
  Sender Class encapsulates methods for transfering data to receiver.
  '''
  def __init__ (self, udp_ip, udp_port):
    # Record ip address and port number of the receiver
    self.dest = (udp_ip, udp_port)
    # Set up the UDP socket
    self.sock = socket.socket (socket.AF_INET, socket.SOCK_DGRAM) 
    self.sock.settimeout(TIMEOUT)
    # Initialize sender window (aka sender buffer)
    self.window = Window (max_size=MAX_WINDOW_SIZE, timeout=1)

  def log(self, msg):
    log_msg = datetime.datetime.now().strftime("%H:%M:%S.%f") + " 4254send: " + msg + "\n"
    sys.stderr.write (log_msg)

  def readData (self):
    # Read data from STDIN
    return sys.stdin.buffer.read (DATA_SIZE)

  def sendSegment (self, seq_no):
    data = self.window.get (seq_no)
    # Add headers to data
    msg = json.dumps({"sequence": seq_no, "data": b64encode(data).decode(), "eof": False})
    # Send sequence number + eof flag + data 
    if self.sock.sendto (msg.encode (), self.dest) < len (msg):
      self.log("[error] unable to fully send packet")
    else:
      self.log("[send data] %d (%d)" % (seq_no, len (data)))

  def sendNextSegment (self, data):
    global SEQUENCE
    
    # Store the data inside the window
    self.window.add (SEQUENCE, data)
    # Mark the starting byte as the sequence number then send segment
    self.sendSegment (SEQUENCE)
    # Update sequence number to next expected byte position to read 
    SEQUENCE += len (data)

  def recvAck (self):
    return self.sock.recvfrom (MSG_SIZE)

  def sendEOF (self):
    end_msg = json.dumps({"eof": True, "data": "", "sequence": SEQUENCE})
    # Send eof 
    if self.sock.sendto (end_msg.encode (), self.dest) < len (end_msg):
      self.log("[error] unable to fully send packet")
    else:
      self.log("[send eof] %d" % SEQUENCE)
  
  def retransmit (self):
    # retransmit all expired segments inside the window
    expired_seqs = self.window.expiredSegments ()
    for expired_seq in expired_seqs:
      self.sendSegment (expired_seq)
      self.window.resetRTO (expired_seq)


def main (ip, port):
  # Find IP and port number from command line argument
  UDP_IP = ip
  UDP_PORT = port
  # Initialize destination (ip address and port) 
  sender = Sender (UDP_IP, UDP_PORT) 

  # Now read in data, then send segments until there is no more data
  # to read from STDIN and window is empty
  data = sender.readData ()
  while len (data) > 0 or not sender.window.isEmpty ():
    
    # Send next segment in line when window is not full
    if not sender.window.isFull () and len (data) > 0:
      sender.sendNextSegment (data)
      data = sender.readData ()
    # Otherwise, wait for next ACK in line to free space inside window
    else:
      sender.log("ABOUT TO SLEEP")
      try:
        (ack, addr) = sender.recvAck ()
      # If no ACKs arrives for a while, retransmit any expired segments inside
      # the window
      except socket.timeout:
        sender.retransmit ()
        continue

      # Process received ACK
      try:
        ack_num = int (ack.decode ())
        sender.log("[recv ack] " + str(ack_num))
        
        # Remove all segments that have sequence number 
        # less than or equal to ack number from the window (cumulative ACKs).
        sender.window.remove (ack_num)

      except (ValueError, KeyError, TypeError):
        sender.log("[recv corrupt packet]")

  # At this point sender have sent all segments successfully
  # Send EOF until receiver ACK that EOF got processed
  eof_send_count = 0
  sender.sendEOF ()
  while True:
    try:
      (ack, addr) = sender.recvAck ()
    except ConnectionResetError:
      sender.log("[recv closed port]")
      break
    except socket.timeout:
      # If receiver have not responded for a long time, assume it is already closed
      if eof_send_count >= 10:
        break
      # Otherwise, resend EOF
      sender.sendEOF ()
      eof_send_count += 1
      continue

    ack_num = int (ack.decode ())
    if ack_num == SEQUENCE:
      sender.log("[recv eof] " + str(ack_num))
      break
    sender.log("[recv ack] " + str(ack_num))

  sys.exit(0)


if __name__ == '__main__':
  # command line argument syntax checking
  if len (sys.argv) != 2 or ":" not in sys.argv[1]:
    sys.stderr.write ("Usage: 4254send <recv_host>:<recv_port>\n")
    sys.exit (-1)

  argv = sys.argv[1].split (":")
  try:
    ip = argv[0]
    port = int (argv[1])
  except ValueError:
    sys.stderr.write ("Usage: 4254send <recv_host>:<recv_port>\n")
    sys.exit (-1)

  # call main function 
  main (ip, port)
